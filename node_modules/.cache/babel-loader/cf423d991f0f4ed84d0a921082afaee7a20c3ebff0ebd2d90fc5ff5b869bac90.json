{"ast":null,"code":"var t = function (t) {\n  this.canvas = document.createElement(\"canvas\"), this.context = this.canvas.getContext(\"2d\"), this.width = this.canvas.width = t.width, this.height = this.canvas.height = t.height, this.context.drawImage(t, 0, 0, this.width, this.height);\n};\nt.prototype.getPixelCount = function () {\n  return this.width * this.height;\n}, t.prototype.getImageData = function () {\n  return this.context.getImageData(0, 0, this.width, this.height);\n};\nvar r = function () {};\nif (r.prototype.getColor = function (t, r) {\n  return this.getPalette(t, 5, r)[0];\n}, r.prototype.getPalette = function (r, n, e) {\n  (void 0 === n || n < 2 || n > 256) && (n = 10), (void 0 === e || e < 1) && (e = 10);\n  for (var i, u, s, a, h = new t(r), c = h.getImageData().data, f = h.getPixelCount(), v = [], p = 0; p < f; p += e) u = c[0 + (i = 4 * p)], s = c[i + 1], a = c[i + 2], c[i + 3] >= 125 && (u > 250 && s > 250 && a > 250 || v.push([u, s, a]));\n  var g = o.quantize(v, n);\n  return g ? g.palette() : null;\n}, r.prototype.getColorFromUrl = function (t, r, n) {\n  var o = document.createElement(\"img\"),\n    e = this;\n  o.addEventListener(\"load\", function () {\n    var i = e.getPalette(o, 5, n);\n    r(i[0], t);\n  }), o.src = t;\n}, r.prototype.getImageData = function (t, r) {\n  var n = new XMLHttpRequest();\n  n.open(\"GET\", t, !0), n.responseType = \"arraybuffer\", n.onload = function () {\n    if (200 == this.status) {\n      var t = new Uint8Array(this.response);\n      o = t.length;\n      for (var n = new Array(o), o = 0; o < t.length; o++) n[o] = String.fromCharCode(t[o]);\n      var e = n.join(\"\"),\n        i = window.btoa(e);\n      r(\"data:image/png;base64,\" + i);\n    }\n  }, n.send();\n}, r.prototype.getColorAsync = function (t, r, n) {\n  var o = this;\n  this.getImageData(t, function (t) {\n    var e = document.createElement(\"img\");\n    e.addEventListener(\"load\", function () {\n      var t = o.getPalette(e, 5, n);\n      r(t[0], this);\n    }), e.src = t;\n  });\n}, !n) var n = {\n  map: function (t, r) {\n    var n = {};\n    return r ? t.map(function (t, o) {\n      return n.index = o, r.call(n, t);\n    }) : t.slice();\n  },\n  naturalOrder: function (t, r) {\n    return t < r ? -1 : t > r ? 1 : 0;\n  },\n  sum: function (t, r) {\n    var n = {};\n    return t.reduce(r ? function (t, o, e) {\n      return n.index = e, t + r.call(n, o);\n    } : function (t, r) {\n      return t + r;\n    }, 0);\n  },\n  max: function (t, r) {\n    return Math.max.apply(null, r ? n.map(t, r) : t);\n  }\n};\nvar o = function () {\n  var t = 5,\n    r = 8 - t,\n    o = 1e3;\n  function e(r, n, o) {\n    return (r << 2 * t) + (n << t) + o;\n  }\n  function i(t) {\n    var r = [],\n      n = !1;\n    function o() {\n      r.sort(t), n = !0;\n    }\n    return {\n      push: function (t) {\n        r.push(t), n = !1;\n      },\n      peek: function (t) {\n        return n || o(), void 0 === t && (t = r.length - 1), r[t];\n      },\n      pop: function () {\n        return n || o(), r.pop();\n      },\n      size: function () {\n        return r.length;\n      },\n      map: function (t) {\n        return r.map(t);\n      },\n      debug: function () {\n        return n || o(), r;\n      }\n    };\n  }\n  function u(t, r, n, o, e, i, u) {\n    this.r1 = t, this.r2 = r, this.g1 = n, this.g2 = o, this.b1 = e, this.b2 = i, this.histo = u;\n  }\n  function s() {\n    this.vboxes = new i(function (t, r) {\n      return n.naturalOrder(t.vbox.count() * t.vbox.volume(), r.vbox.count() * r.vbox.volume());\n    });\n  }\n  function a(t, r) {\n    if (r.count()) {\n      var o = r.r2 - r.r1 + 1,\n        i = r.g2 - r.g1 + 1,\n        u = n.max([o, i, r.b2 - r.b1 + 1]);\n      if (1 == r.count()) return [r.copy()];\n      var s,\n        a,\n        h,\n        c,\n        f = 0,\n        v = [],\n        p = [];\n      if (u == o) for (s = r.r1; s <= r.r2; s++) {\n        for (c = 0, a = r.g1; a <= r.g2; a++) for (h = r.b1; h <= r.b2; h++) c += t[e(s, a, h)] || 0;\n        v[s] = f += c;\n      } else if (u == i) for (s = r.g1; s <= r.g2; s++) {\n        for (c = 0, a = r.r1; a <= r.r2; a++) for (h = r.b1; h <= r.b2; h++) c += t[e(a, s, h)] || 0;\n        v[s] = f += c;\n      } else for (s = r.b1; s <= r.b2; s++) {\n        for (c = 0, a = r.r1; a <= r.r2; a++) for (h = r.g1; h <= r.g2; h++) c += t[e(a, h, s)] || 0;\n        v[s] = f += c;\n      }\n      return v.forEach(function (t, r) {\n        p[r] = f - t;\n      }), function (t) {\n        var n,\n          o,\n          e,\n          i,\n          u,\n          a = t + \"1\",\n          h = t + \"2\",\n          c = 0;\n        for (s = r[a]; s <= r[h]; s++) if (v[s] > f / 2) {\n          for (e = r.copy(), i = r.copy(), u = (n = s - r[a]) <= (o = r[h] - s) ? Math.min(r[h] - 1, ~~(s + o / 2)) : Math.max(r[a], ~~(s - 1 - n / 2)); !v[u];) u++;\n          for (c = p[u]; !c && v[u - 1];) c = p[--u];\n          return e[h] = u, i[a] = e[h] + 1, [e, i];\n        }\n      }(u == o ? \"r\" : u == i ? \"g\" : \"b\");\n    }\n  }\n  return u.prototype = {\n    volume: function (t) {\n      return this._volume && !t || (this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1)), this._volume;\n    },\n    count: function (t) {\n      var r = this.histo;\n      if (!this._count_set || t) {\n        var n,\n          o,\n          i,\n          u = 0;\n        for (n = this.r1; n <= this.r2; n++) for (o = this.g1; o <= this.g2; o++) for (i = this.b1; i <= this.b2; i++) u += r[e(n, o, i)] || 0;\n        this._count = u, this._count_set = !0;\n      }\n      return this._count;\n    },\n    copy: function () {\n      return new u(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);\n    },\n    avg: function (r) {\n      var n = this.histo;\n      if (!this._avg || r) {\n        var o,\n          i,\n          u,\n          s,\n          a = 0,\n          h = 1 << 8 - t,\n          c = 0,\n          f = 0,\n          v = 0;\n        for (i = this.r1; i <= this.r2; i++) for (u = this.g1; u <= this.g2; u++) for (s = this.b1; s <= this.b2; s++) a += o = n[e(i, u, s)] || 0, c += o * (i + .5) * h, f += o * (u + .5) * h, v += o * (s + .5) * h;\n        this._avg = a ? [~~(c / a), ~~(f / a), ~~(v / a)] : [~~(h * (this.r1 + this.r2 + 1) / 2), ~~(h * (this.g1 + this.g2 + 1) / 2), ~~(h * (this.b1 + this.b2 + 1) / 2)];\n      }\n      return this._avg;\n    },\n    contains: function (t) {\n      var n = t[0] >> r,\n        o = t[1] >> r,\n        e = t[2] >> r;\n      return n >= this.r1 && n <= this.r2 && o >= this.g1 && o <= this.g2 && e >= this.b1 && e <= this.b2;\n    }\n  }, s.prototype = {\n    push: function (t) {\n      this.vboxes.push({\n        vbox: t,\n        color: t.avg()\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (t) {\n        return t.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (t) {\n      for (var r = this.vboxes, n = 0; n < r.size(); n++) if (r.peek(n).vbox.contains(t)) return r.peek(n).color;\n      return this.nearest(t);\n    },\n    nearest: function (t) {\n      for (var r, n, o, e = this.vboxes, i = 0; i < e.size(); i++) ((n = Math.sqrt(Math.pow(t[0] - e.peek(i).color[0], 2) + Math.pow(t[1] - e.peek(i).color[1], 2) + Math.pow(t[2] - e.peek(i).color[2], 2))) < r || void 0 === r) && (r = n, o = e.peek(i).color);\n      return o;\n    },\n    forcebw: function () {\n      var t = this.vboxes;\n      t.sort(function (t, r) {\n        return n.naturalOrder(n.sum(t.color), n.sum(r.color));\n      });\n      var r = t[0].color;\n      r[0] < 5 && r[1] < 5 && r[2] < 5 && (t[0].color = [0, 0, 0]);\n      var o = t.length - 1,\n        e = t[o].color;\n      e[0] > 251 && e[1] > 251 && e[2] > 251 && (t[o].color = [255, 255, 255]);\n    }\n  }, {\n    quantize: function (h, c) {\n      if (!h.length || c < 2 || c > 256) return !1;\n      var f = function (n) {\n        var o,\n          i = new Array(1 << 3 * t);\n        return n.forEach(function (t) {\n          o = e(t[0] >> r, t[1] >> r, t[2] >> r), i[o] = (i[o] || 0) + 1;\n        }), i;\n      }(h);\n      f.forEach(function () {});\n      var v = function (t, n) {\n          var o,\n            e,\n            i,\n            s = 1e6,\n            a = 0,\n            h = 1e6,\n            c = 0,\n            f = 1e6,\n            v = 0;\n          return t.forEach(function (t) {\n            (o = t[0] >> r) < s ? s = o : o > a && (a = o), (e = t[1] >> r) < h ? h = e : e > c && (c = e), (i = t[2] >> r) < f ? f = i : i > v && (v = i);\n          }), new u(s, a, h, c, f, v, n);\n        }(h, f),\n        p = new i(function (t, r) {\n          return n.naturalOrder(t.count(), r.count());\n        });\n      function g(t, r) {\n        for (var n, e = 1, i = 0; i < o;) if ((n = t.pop()).count()) {\n          var u = a(f, n),\n            s = u[0],\n            h = u[1];\n          if (!s) return;\n          if (t.push(s), h && (t.push(h), e++), e >= r) return;\n          if (i++ > o) return;\n        } else t.push(n), i++;\n      }\n      p.push(v), g(p, .75 * c);\n      for (var l = new i(function (t, r) {\n        return n.naturalOrder(t.count() * t.volume(), r.count() * r.volume());\n      }); p.size();) l.push(p.pop());\n      g(l, c - l.size());\n      for (var b = new s(); l.size();) b.push(l.pop());\n      return b;\n    }\n  };\n}();\nexport default r;","map":{"version":3,"names":["t","CanvasImage","canvas","document","createElement","context","getContext","width","height","drawImage","prototype","getPixelCount","getImageData","r","ColorThief","getColor","getPalette","n","e","i","u","s","a","h","c","data","f","v","p","push","g","o","quantize","palette","getColorFromUrl","addEventListener","src","XMLHttpRequest","open","responseType","onload","status","Uint8Array","response","length","Array","String","fromCharCode","join","window","btoa","send","getColorAsync","map","index","call","slice","naturalOrder","sum","reduce","max","Math","apply","sort","peek","pop","size","debug","r1","r2","g1","g2","b1","b2","histo","vboxes","vbox","count","volume","copy","forEach","min","_volume","_count_set","_count","avg","_avg","contains","color","nearest","sqrt","pow","forcebw","l","b"],"sources":["C:\\Users\\agnes\\Documents\\GitHub\\agn-ese.github.io\\node_modules\\colorthief\\src\\color-thief.js"],"sourcesContent":["/*\n * Color Thief v2.2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\n\nvar CanvasImage = function (image) {\n    this.canvas  = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n\n    this.width  = this.canvas.width  = image.width;\n    this.height = this.canvas.height = image.height;\n\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.getPixelCount = function () {\n    return this.width * this.height;\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nvar ColorThief = function () {};\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function(sourceImage, quality) {\n    var palette       = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\n\n    if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) {\n        colorCount = 10;\n    }\n    if (typeof quality === 'undefined' || quality < 1) {\n        quality = 10;\n    }\n\n    // Create custom CanvasImage object\n    var image      = new CanvasImage(sourceImage);\n    var imageData  = image.getImageData();\n    var pixels     = imageData.data;\n    var pixelCount = image.getPixelCount();\n\n    // Store the RGB values in an array format suitable for quantize function\n    var pixelArray = [];\n    for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n        // If pixel is mostly opaque and not white\n        if (a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    var cmap    = MMCQ.quantize(pixelArray, colorCount);\n    var palette = cmap? cmap.palette() : null;\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\n    let sourceImage = document.createElement(\"img\");\n    var thief = this;\n    sourceImage.addEventListener('load' , function(){\n        var palette = thief.getPalette(sourceImage, 5, quality);\n        var dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function(imageUrl, callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function() {\n        if (this.status == 200) {\n            let uInt8Array = new Uint8Array(this.response)\n            i = uInt8Array.length\n            let binaryString = new Array(i);\n            for (var i = 0; i < uInt8Array.length; i++){\n                binaryString[i] = String.fromCharCode(uInt8Array[i])\n            }\n            let data = binaryString.join('')\n            let base64 = window.btoa(data)\n            callback (\"data:image/png;base64,\"+base64)\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\n    var thief = this;\n    this.getImageData(imageUrl, function(imageData){\n        let sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load' , function(){\n            var palette = thief.getPalette(sourceImage, 5, quality);\n            var dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\n\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n\n// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n          var o = {};\n          return f ? array.map(function(d, i) { o.index = i; return f.call(o, d); }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n          var o = {};\n          return array.reduce(f ? function(p, d, i) { o.index = i; return p + f.call(o, d); } : function(p, d) { return p + d; }, 0);\n        },\n        max: function(array, f) {\n          return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    };\n}\n\n\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n * @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n    return cmap.map(p);\n});\n\n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5;\n    var rshift = 8 - sigbits;\n    var maxIterations = 1000;\n    var fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n    function PQueue(comparator) {\n        var contents = [];\n        var sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index===undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0;\n                var index; var i; var j; var k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             index = getColorIndex(i,j,k);\n                             npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0;\n                var mult = 1 << (8 - sigbits);\n                var rsum = 0;\n                var gsum = 0;\n                var bsum = 0;\n                var hval;\n                var i, j, k;\n                var histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             histoindex = getColorIndex(i,j,k);\n                             hval = histo[histoindex] || 0;\n                             ntot += hval;\n                             rsum += (hval * (i + 0.5) * mult);\n                             gsum += (hval * (j + 0.5) * mult);\n                             bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];\n                } else {\n                    // console.log('empty box');\n                    vbox._avg = [\n                        ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),\n                        ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),\n                        ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)\n                    ];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this;\n            var rval = pixel[0] >> rshift;\n            var gval = pixel[1] >> rshift;\n            var bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                    gval >= vbox.g1 && gval <= vbox.g2 &&\n                    bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n    function CMap() {\n        this.vboxes = new PQueue(function(a,b) {\n            return pv.naturalOrder(\n                a.vbox.count()*a.vbox.volume(),\n                b.vbox.count()*b.vbox.volume()\n            );\n        });\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) { return vb.color; });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i=0; i<vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes;\n            var d1;\n            var d2;\n            var pColor;\n            for (var i=0; i<vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));});\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0,0,0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length-1;\n            var highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255,255,255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits);\n        var histo = new Array(histosize);\n        var index; var rval; var gval; var bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin=1000000; var rmax=0;\n        var gmin=1000000; var gmax=0;\n        var bmin=1000000; var bmax=0;\n        var rval; var gval; var bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax)  bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1;\n        var gw = vbox.g2 - vbox.g1 + 1;\n        var bw = vbox.b2 - vbox.b1 + 1;\n        var maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()];\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0;\n        var partialsum = [];\n        var lookaheadsum = [];\n        var i; var j; var k; var sum; var index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i,j,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j,i,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else {  /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j,k,i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d,i) {\n            lookaheadsum[i] = total-d;\n        });\n        function doCut(color) {\n            var dim1 = color + '1';\n            var dim2 = color + '2';\n            var left; var right; var vbox1; var vbox2; var d2; var count2=0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n//                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n//            console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels);\n        // histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() { nColors++; });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo);\n            var pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()); });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n        function iter(lh, target) {\n            var ncolors = 1;\n            var niters = 0;\n            var vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count())  { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox);\n                    var vbox1 = vboxes[0];\n                    var vbox2 = vboxes[1];\n\n                if (!vbox1) {\n//                  console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) {  /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n//                    console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a,b) {\n            return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume());\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    };\n})();\n\nexport default ColorThief;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}